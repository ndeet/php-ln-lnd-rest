<?php
/**
 * LnrpcOpenChannelRequest
 *
 * PHP version 5
 *
 * @category Class
 * @package  Lnd\Rest
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * rpc.proto
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: version not set
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.8
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Lnd\Rest\Model;

use \ArrayAccess;
use \Lnd\Rest\ObjectSerializer;

/**
 * LnrpcOpenChannelRequest Class Doc Comment
 *
 * @category Class
 * @package  Lnd\Rest
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class LnrpcOpenChannelRequest implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'lnrpcOpenChannelRequest';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'satPerVbyte' => 'string',
        'nodePubkey' => 'string',
        'nodePubkeyString' => 'string',
        'localFundingAmount' => 'string',
        'pushSat' => 'string',
        'targetConf' => 'int',
        'satPerByte' => 'string',
        'private' => 'bool',
        'minHtlcMsat' => 'string',
        'remoteCsvDelay' => 'int',
        'minConfs' => 'int',
        'spendUnconfirmed' => 'bool',
        'closeAddress' => 'string',
        'fundingShim' => '\Lnd\Rest\Model\LnrpcFundingShim',
        'remoteMaxValueInFlightMsat' => 'string',
        'remoteMaxHtlcs' => 'int',
        'maxLocalCsv' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'satPerVbyte' => 'uint64',
        'nodePubkey' => 'byte',
        'nodePubkeyString' => null,
        'localFundingAmount' => 'int64',
        'pushSat' => 'int64',
        'targetConf' => 'int32',
        'satPerByte' => 'int64',
        'private' => 'boolean',
        'minHtlcMsat' => 'int64',
        'remoteCsvDelay' => 'int64',
        'minConfs' => 'int32',
        'spendUnconfirmed' => 'boolean',
        'closeAddress' => null,
        'fundingShim' => null,
        'remoteMaxValueInFlightMsat' => 'uint64',
        'remoteMaxHtlcs' => 'int64',
        'maxLocalCsv' => 'int64'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'satPerVbyte' => 'sat_per_vbyte',
        'nodePubkey' => 'node_pubkey',
        'nodePubkeyString' => 'node_pubkey_string',
        'localFundingAmount' => 'local_funding_amount',
        'pushSat' => 'push_sat',
        'targetConf' => 'target_conf',
        'satPerByte' => 'sat_per_byte',
        'private' => 'private',
        'minHtlcMsat' => 'min_htlc_msat',
        'remoteCsvDelay' => 'remote_csv_delay',
        'minConfs' => 'min_confs',
        'spendUnconfirmed' => 'spend_unconfirmed',
        'closeAddress' => 'close_address',
        'fundingShim' => 'funding_shim',
        'remoteMaxValueInFlightMsat' => 'remote_max_value_in_flight_msat',
        'remoteMaxHtlcs' => 'remote_max_htlcs',
        'maxLocalCsv' => 'max_local_csv'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'satPerVbyte' => 'setSatPerVbyte',
        'nodePubkey' => 'setNodePubkey',
        'nodePubkeyString' => 'setNodePubkeyString',
        'localFundingAmount' => 'setLocalFundingAmount',
        'pushSat' => 'setPushSat',
        'targetConf' => 'setTargetConf',
        'satPerByte' => 'setSatPerByte',
        'private' => 'setPrivate',
        'minHtlcMsat' => 'setMinHtlcMsat',
        'remoteCsvDelay' => 'setRemoteCsvDelay',
        'minConfs' => 'setMinConfs',
        'spendUnconfirmed' => 'setSpendUnconfirmed',
        'closeAddress' => 'setCloseAddress',
        'fundingShim' => 'setFundingShim',
        'remoteMaxValueInFlightMsat' => 'setRemoteMaxValueInFlightMsat',
        'remoteMaxHtlcs' => 'setRemoteMaxHtlcs',
        'maxLocalCsv' => 'setMaxLocalCsv'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'satPerVbyte' => 'getSatPerVbyte',
        'nodePubkey' => 'getNodePubkey',
        'nodePubkeyString' => 'getNodePubkeyString',
        'localFundingAmount' => 'getLocalFundingAmount',
        'pushSat' => 'getPushSat',
        'targetConf' => 'getTargetConf',
        'satPerByte' => 'getSatPerByte',
        'private' => 'getPrivate',
        'minHtlcMsat' => 'getMinHtlcMsat',
        'remoteCsvDelay' => 'getRemoteCsvDelay',
        'minConfs' => 'getMinConfs',
        'spendUnconfirmed' => 'getSpendUnconfirmed',
        'closeAddress' => 'getCloseAddress',
        'fundingShim' => 'getFundingShim',
        'remoteMaxValueInFlightMsat' => 'getRemoteMaxValueInFlightMsat',
        'remoteMaxHtlcs' => 'getRemoteMaxHtlcs',
        'maxLocalCsv' => 'getMaxLocalCsv'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['satPerVbyte'] = isset($data['satPerVbyte']) ? $data['satPerVbyte'] : null;
        $this->container['nodePubkey'] = isset($data['nodePubkey']) ? $data['nodePubkey'] : null;
        $this->container['nodePubkeyString'] = isset($data['nodePubkeyString']) ? $data['nodePubkeyString'] : null;
        $this->container['localFundingAmount'] = isset($data['localFundingAmount']) ? $data['localFundingAmount'] : null;
        $this->container['pushSat'] = isset($data['pushSat']) ? $data['pushSat'] : null;
        $this->container['targetConf'] = isset($data['targetConf']) ? $data['targetConf'] : null;
        $this->container['satPerByte'] = isset($data['satPerByte']) ? $data['satPerByte'] : null;
        $this->container['private'] = isset($data['private']) ? $data['private'] : null;
        $this->container['minHtlcMsat'] = isset($data['minHtlcMsat']) ? $data['minHtlcMsat'] : null;
        $this->container['remoteCsvDelay'] = isset($data['remoteCsvDelay']) ? $data['remoteCsvDelay'] : null;
        $this->container['minConfs'] = isset($data['minConfs']) ? $data['minConfs'] : null;
        $this->container['spendUnconfirmed'] = isset($data['spendUnconfirmed']) ? $data['spendUnconfirmed'] : null;
        $this->container['closeAddress'] = isset($data['closeAddress']) ? $data['closeAddress'] : null;
        $this->container['fundingShim'] = isset($data['fundingShim']) ? $data['fundingShim'] : null;
        $this->container['remoteMaxValueInFlightMsat'] = isset($data['remoteMaxValueInFlightMsat']) ? $data['remoteMaxValueInFlightMsat'] : null;
        $this->container['remoteMaxHtlcs'] = isset($data['remoteMaxHtlcs']) ? $data['remoteMaxHtlcs'] : null;
        $this->container['maxLocalCsv'] = isset($data['maxLocalCsv']) ? $data['maxLocalCsv'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['nodePubkey']) && !preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $this->container['nodePubkey'])) {
            $invalidProperties[] = "invalid value for 'nodePubkey', must be conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets satPerVbyte
     *
     * @return string
     */
    public function getSatPerVbyte()
    {
        return $this->container['satPerVbyte'];
    }

    /**
     * Sets satPerVbyte
     *
     * @param string $satPerVbyte A manual fee rate set in sat/vbyte that should be used when crafting the funding transaction.
     *
     * @return $this
     */
    public function setSatPerVbyte($satPerVbyte)
    {
        $this->container['satPerVbyte'] = $satPerVbyte;

        return $this;
    }

    /**
     * Gets nodePubkey
     *
     * @return string
     */
    public function getNodePubkey()
    {
        return $this->container['nodePubkey'];
    }

    /**
     * Sets nodePubkey
     *
     * @param string $nodePubkey The pubkey of the node to open a channel with. When using REST, this field must be encoded as base64.
     *
     * @return $this
     */
    public function setNodePubkey($nodePubkey)
    {

        if (!is_null($nodePubkey) && (!preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $nodePubkey))) {
            throw new \InvalidArgumentException("invalid value for $nodePubkey when calling LnrpcOpenChannelRequest., must conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.");
        }

        $this->container['nodePubkey'] = $nodePubkey;

        return $this;
    }

    /**
     * Gets nodePubkeyString
     *
     * @return string
     */
    public function getNodePubkeyString()
    {
        return $this->container['nodePubkeyString'];
    }

    /**
     * Sets nodePubkeyString
     *
     * @param string $nodePubkeyString The hex encoded pubkey of the node to open a channel with. Deprecated now that the REST gateway supports base64 encoding of bytes fields.
     *
     * @return $this
     */
    public function setNodePubkeyString($nodePubkeyString)
    {
        $this->container['nodePubkeyString'] = $nodePubkeyString;

        return $this;
    }

    /**
     * Gets localFundingAmount
     *
     * @return string
     */
    public function getLocalFundingAmount()
    {
        return $this->container['localFundingAmount'];
    }

    /**
     * Sets localFundingAmount
     *
     * @param string $localFundingAmount localFundingAmount
     *
     * @return $this
     */
    public function setLocalFundingAmount($localFundingAmount)
    {
        $this->container['localFundingAmount'] = $localFundingAmount;

        return $this;
    }

    /**
     * Gets pushSat
     *
     * @return string
     */
    public function getPushSat()
    {
        return $this->container['pushSat'];
    }

    /**
     * Sets pushSat
     *
     * @param string $pushSat pushSat
     *
     * @return $this
     */
    public function setPushSat($pushSat)
    {
        $this->container['pushSat'] = $pushSat;

        return $this;
    }

    /**
     * Gets targetConf
     *
     * @return int
     */
    public function getTargetConf()
    {
        return $this->container['targetConf'];
    }

    /**
     * Sets targetConf
     *
     * @param int $targetConf The target number of blocks that the funding transaction should be confirmed by.
     *
     * @return $this
     */
    public function setTargetConf($targetConf)
    {
        $this->container['targetConf'] = $targetConf;

        return $this;
    }

    /**
     * Gets satPerByte
     *
     * @return string
     */
    public function getSatPerByte()
    {
        return $this->container['satPerByte'];
    }

    /**
     * Sets satPerByte
     *
     * @param string $satPerByte Deprecated, use sat_per_vbyte. A manual fee rate set in sat/vbyte that should be used when crafting the funding transaction.
     *
     * @return $this
     */
    public function setSatPerByte($satPerByte)
    {
        $this->container['satPerByte'] = $satPerByte;

        return $this;
    }

    /**
     * Gets private
     *
     * @return bool
     */
    public function getPrivate()
    {
        return $this->container['private'];
    }

    /**
     * Sets private
     *
     * @param bool $private Whether this channel should be private, not announced to the greater network.
     *
     * @return $this
     */
    public function setPrivate($private)
    {
        $this->container['private'] = $private;

        return $this;
    }

    /**
     * Gets minHtlcMsat
     *
     * @return string
     */
    public function getMinHtlcMsat()
    {
        return $this->container['minHtlcMsat'];
    }

    /**
     * Sets minHtlcMsat
     *
     * @param string $minHtlcMsat The minimum value in millisatoshi we will require for incoming HTLCs on the channel.
     *
     * @return $this
     */
    public function setMinHtlcMsat($minHtlcMsat)
    {
        $this->container['minHtlcMsat'] = $minHtlcMsat;

        return $this;
    }

    /**
     * Gets remoteCsvDelay
     *
     * @return int
     */
    public function getRemoteCsvDelay()
    {
        return $this->container['remoteCsvDelay'];
    }

    /**
     * Sets remoteCsvDelay
     *
     * @param int $remoteCsvDelay The delay we require on the remote's commitment transaction. If this is not set, it will be scaled automatically with the channel size.
     *
     * @return $this
     */
    public function setRemoteCsvDelay($remoteCsvDelay)
    {
        $this->container['remoteCsvDelay'] = $remoteCsvDelay;

        return $this;
    }

    /**
     * Gets minConfs
     *
     * @return int
     */
    public function getMinConfs()
    {
        return $this->container['minConfs'];
    }

    /**
     * Sets minConfs
     *
     * @param int $minConfs The minimum number of confirmations each one of your outputs used for the funding transaction must satisfy.
     *
     * @return $this
     */
    public function setMinConfs($minConfs)
    {
        $this->container['minConfs'] = $minConfs;

        return $this;
    }

    /**
     * Gets spendUnconfirmed
     *
     * @return bool
     */
    public function getSpendUnconfirmed()
    {
        return $this->container['spendUnconfirmed'];
    }

    /**
     * Sets spendUnconfirmed
     *
     * @param bool $spendUnconfirmed Whether unconfirmed outputs should be used as inputs for the funding transaction.
     *
     * @return $this
     */
    public function setSpendUnconfirmed($spendUnconfirmed)
    {
        $this->container['spendUnconfirmed'] = $spendUnconfirmed;

        return $this;
    }

    /**
     * Gets closeAddress
     *
     * @return string
     */
    public function getCloseAddress()
    {
        return $this->container['closeAddress'];
    }

    /**
     * Sets closeAddress
     *
     * @param string $closeAddress Close address is an optional address which specifies the address to which funds should be paid out to upon cooperative close. This field may only be set if the peer supports the option upfront feature bit (call listpeers to check). The remote peer will only accept cooperative closes to this address if it is set.  Note: If this value is set on channel creation, you will *not* be able to cooperatively close out to a different address.
     *
     * @return $this
     */
    public function setCloseAddress($closeAddress)
    {
        $this->container['closeAddress'] = $closeAddress;

        return $this;
    }

    /**
     * Gets fundingShim
     *
     * @return \Lnd\Rest\Model\LnrpcFundingShim
     */
    public function getFundingShim()
    {
        return $this->container['fundingShim'];
    }

    /**
     * Sets fundingShim
     *
     * @param \Lnd\Rest\Model\LnrpcFundingShim $fundingShim Funding shims are an optional argument that allow the caller to intercept certain funding functionality. For example, a shim can be provided to use a particular key for the commitment key (ideally cold) rather than use one that is generated by the wallet as normal, or signal that signing will be carried out in an interactive manner (PSBT based).
     *
     * @return $this
     */
    public function setFundingShim($fundingShim)
    {
        $this->container['fundingShim'] = $fundingShim;

        return $this;
    }

    /**
     * Gets remoteMaxValueInFlightMsat
     *
     * @return string
     */
    public function getRemoteMaxValueInFlightMsat()
    {
        return $this->container['remoteMaxValueInFlightMsat'];
    }

    /**
     * Sets remoteMaxValueInFlightMsat
     *
     * @param string $remoteMaxValueInFlightMsat The maximum amount of coins in millisatoshi that can be pending within the channel. It only applies to the remote party.
     *
     * @return $this
     */
    public function setRemoteMaxValueInFlightMsat($remoteMaxValueInFlightMsat)
    {
        $this->container['remoteMaxValueInFlightMsat'] = $remoteMaxValueInFlightMsat;

        return $this;
    }

    /**
     * Gets remoteMaxHtlcs
     *
     * @return int
     */
    public function getRemoteMaxHtlcs()
    {
        return $this->container['remoteMaxHtlcs'];
    }

    /**
     * Sets remoteMaxHtlcs
     *
     * @param int $remoteMaxHtlcs The maximum number of concurrent HTLCs we will allow the remote party to add to the commitment transaction.
     *
     * @return $this
     */
    public function setRemoteMaxHtlcs($remoteMaxHtlcs)
    {
        $this->container['remoteMaxHtlcs'] = $remoteMaxHtlcs;

        return $this;
    }

    /**
     * Gets maxLocalCsv
     *
     * @return int
     */
    public function getMaxLocalCsv()
    {
        return $this->container['maxLocalCsv'];
    }

    /**
     * Sets maxLocalCsv
     *
     * @param int $maxLocalCsv Max local csv is the maximum csv delay we will allow for our own commitment transaction.
     *
     * @return $this
     */
    public function setMaxLocalCsv($maxLocalCsv)
    {
        $this->container['maxLocalCsv'] = $maxLocalCsv;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


