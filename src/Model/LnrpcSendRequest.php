<?php
/**
 * LnrpcSendRequest
 *
 * PHP version 5
 *
 * @category Class
 * @package  Lnd\Rest
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * rpc.proto
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: version not set
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.8
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Lnd\Rest\Model;

use \ArrayAccess;
use \Lnd\Rest\ObjectSerializer;

/**
 * LnrpcSendRequest Class Doc Comment
 *
 * @category Class
 * @package  Lnd\Rest
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class LnrpcSendRequest implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'lnrpcSendRequest';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'dest' => 'string',
        'destString' => 'string',
        'amt' => 'string',
        'amtMsat' => 'string',
        'paymentHash' => 'string',
        'paymentHashString' => 'string',
        'paymentRequest' => 'string',
        'finalCltvDelta' => 'int',
        'feeLimit' => '\Lnd\Rest\Model\LnrpcFeeLimit',
        'outgoingChanId' => 'string',
        'lastHopPubkey' => 'string',
        'cltvLimit' => 'int',
        'destCustomRecords' => 'map[string,string]',
        'allowSelfPayment' => 'bool',
        'destFeatures' => '\Lnd\Rest\Model\LnrpcFeatureBit[]',
        'paymentAddr' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'dest' => 'byte',
        'destString' => null,
        'amt' => 'int64',
        'amtMsat' => 'int64',
        'paymentHash' => 'byte',
        'paymentHashString' => null,
        'paymentRequest' => null,
        'finalCltvDelta' => 'int32',
        'feeLimit' => null,
        'outgoingChanId' => 'uint64',
        'lastHopPubkey' => 'byte',
        'cltvLimit' => 'int64',
        'destCustomRecords' => 'byte',
        'allowSelfPayment' => 'boolean',
        'destFeatures' => null,
        'paymentAddr' => 'byte'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'dest' => 'dest',
        'destString' => 'dest_string',
        'amt' => 'amt',
        'amtMsat' => 'amt_msat',
        'paymentHash' => 'payment_hash',
        'paymentHashString' => 'payment_hash_string',
        'paymentRequest' => 'payment_request',
        'finalCltvDelta' => 'final_cltv_delta',
        'feeLimit' => 'fee_limit',
        'outgoingChanId' => 'outgoing_chan_id',
        'lastHopPubkey' => 'last_hop_pubkey',
        'cltvLimit' => 'cltv_limit',
        'destCustomRecords' => 'dest_custom_records',
        'allowSelfPayment' => 'allow_self_payment',
        'destFeatures' => 'dest_features',
        'paymentAddr' => 'payment_addr'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'dest' => 'setDest',
        'destString' => 'setDestString',
        'amt' => 'setAmt',
        'amtMsat' => 'setAmtMsat',
        'paymentHash' => 'setPaymentHash',
        'paymentHashString' => 'setPaymentHashString',
        'paymentRequest' => 'setPaymentRequest',
        'finalCltvDelta' => 'setFinalCltvDelta',
        'feeLimit' => 'setFeeLimit',
        'outgoingChanId' => 'setOutgoingChanId',
        'lastHopPubkey' => 'setLastHopPubkey',
        'cltvLimit' => 'setCltvLimit',
        'destCustomRecords' => 'setDestCustomRecords',
        'allowSelfPayment' => 'setAllowSelfPayment',
        'destFeatures' => 'setDestFeatures',
        'paymentAddr' => 'setPaymentAddr'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'dest' => 'getDest',
        'destString' => 'getDestString',
        'amt' => 'getAmt',
        'amtMsat' => 'getAmtMsat',
        'paymentHash' => 'getPaymentHash',
        'paymentHashString' => 'getPaymentHashString',
        'paymentRequest' => 'getPaymentRequest',
        'finalCltvDelta' => 'getFinalCltvDelta',
        'feeLimit' => 'getFeeLimit',
        'outgoingChanId' => 'getOutgoingChanId',
        'lastHopPubkey' => 'getLastHopPubkey',
        'cltvLimit' => 'getCltvLimit',
        'destCustomRecords' => 'getDestCustomRecords',
        'allowSelfPayment' => 'getAllowSelfPayment',
        'destFeatures' => 'getDestFeatures',
        'paymentAddr' => 'getPaymentAddr'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['dest'] = isset($data['dest']) ? $data['dest'] : null;
        $this->container['destString'] = isset($data['destString']) ? $data['destString'] : null;
        $this->container['amt'] = isset($data['amt']) ? $data['amt'] : null;
        $this->container['amtMsat'] = isset($data['amtMsat']) ? $data['amtMsat'] : null;
        $this->container['paymentHash'] = isset($data['paymentHash']) ? $data['paymentHash'] : null;
        $this->container['paymentHashString'] = isset($data['paymentHashString']) ? $data['paymentHashString'] : null;
        $this->container['paymentRequest'] = isset($data['paymentRequest']) ? $data['paymentRequest'] : null;
        $this->container['finalCltvDelta'] = isset($data['finalCltvDelta']) ? $data['finalCltvDelta'] : null;
        $this->container['feeLimit'] = isset($data['feeLimit']) ? $data['feeLimit'] : null;
        $this->container['outgoingChanId'] = isset($data['outgoingChanId']) ? $data['outgoingChanId'] : null;
        $this->container['lastHopPubkey'] = isset($data['lastHopPubkey']) ? $data['lastHopPubkey'] : null;
        $this->container['cltvLimit'] = isset($data['cltvLimit']) ? $data['cltvLimit'] : null;
        $this->container['destCustomRecords'] = isset($data['destCustomRecords']) ? $data['destCustomRecords'] : null;
        $this->container['allowSelfPayment'] = isset($data['allowSelfPayment']) ? $data['allowSelfPayment'] : null;
        $this->container['destFeatures'] = isset($data['destFeatures']) ? $data['destFeatures'] : null;
        $this->container['paymentAddr'] = isset($data['paymentAddr']) ? $data['paymentAddr'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['dest']) && !preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $this->container['dest'])) {
            $invalidProperties[] = "invalid value for 'dest', must be conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.";
        }

        if (!is_null($this->container['paymentHash']) && !preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $this->container['paymentHash'])) {
            $invalidProperties[] = "invalid value for 'paymentHash', must be conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.";
        }

        if (!is_null($this->container['lastHopPubkey']) && !preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $this->container['lastHopPubkey'])) {
            $invalidProperties[] = "invalid value for 'lastHopPubkey', must be conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.";
        }

        if (!is_null($this->container['paymentAddr']) && !preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $this->container['paymentAddr'])) {
            $invalidProperties[] = "invalid value for 'paymentAddr', must be conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets dest
     *
     * @return string
     */
    public function getDest()
    {
        return $this->container['dest'];
    }

    /**
     * Sets dest
     *
     * @param string $dest The identity pubkey of the payment recipient. When using REST, this field must be encoded as base64.
     *
     * @return $this
     */
    public function setDest($dest)
    {

        if (!is_null($dest) && (!preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $dest))) {
            throw new \InvalidArgumentException("invalid value for $dest when calling LnrpcSendRequest., must conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.");
        }

        $this->container['dest'] = $dest;

        return $this;
    }

    /**
     * Gets destString
     *
     * @return string
     */
    public function getDestString()
    {
        return $this->container['destString'];
    }

    /**
     * Sets destString
     *
     * @param string $destString The hex-encoded identity pubkey of the payment recipient. Deprecated now that the REST gateway supports base64 encoding of bytes fields.
     *
     * @return $this
     */
    public function setDestString($destString)
    {
        $this->container['destString'] = $destString;

        return $this;
    }

    /**
     * Gets amt
     *
     * @return string
     */
    public function getAmt()
    {
        return $this->container['amt'];
    }

    /**
     * Sets amt
     *
     * @param string $amt The amount to send expressed in satoshis.  The fields amt and amt_msat are mutually exclusive.
     *
     * @return $this
     */
    public function setAmt($amt)
    {
        $this->container['amt'] = $amt;

        return $this;
    }

    /**
     * Gets amtMsat
     *
     * @return string
     */
    public function getAmtMsat()
    {
        return $this->container['amtMsat'];
    }

    /**
     * Sets amtMsat
     *
     * @param string $amtMsat The amount to send expressed in millisatoshis.  The fields amt and amt_msat are mutually exclusive.
     *
     * @return $this
     */
    public function setAmtMsat($amtMsat)
    {
        $this->container['amtMsat'] = $amtMsat;

        return $this;
    }

    /**
     * Gets paymentHash
     *
     * @return string
     */
    public function getPaymentHash()
    {
        return $this->container['paymentHash'];
    }

    /**
     * Sets paymentHash
     *
     * @param string $paymentHash The hash to use within the payment's HTLC. When using REST, this field must be encoded as base64.
     *
     * @return $this
     */
    public function setPaymentHash($paymentHash)
    {

        if (!is_null($paymentHash) && (!preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $paymentHash))) {
            throw new \InvalidArgumentException("invalid value for $paymentHash when calling LnrpcSendRequest., must conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.");
        }

        $this->container['paymentHash'] = $paymentHash;

        return $this;
    }

    /**
     * Gets paymentHashString
     *
     * @return string
     */
    public function getPaymentHashString()
    {
        return $this->container['paymentHashString'];
    }

    /**
     * Sets paymentHashString
     *
     * @param string $paymentHashString The hex-encoded hash to use within the payment's HTLC. Deprecated now that the REST gateway supports base64 encoding of bytes fields.
     *
     * @return $this
     */
    public function setPaymentHashString($paymentHashString)
    {
        $this->container['paymentHashString'] = $paymentHashString;

        return $this;
    }

    /**
     * Gets paymentRequest
     *
     * @return string
     */
    public function getPaymentRequest()
    {
        return $this->container['paymentRequest'];
    }

    /**
     * Sets paymentRequest
     *
     * @param string $paymentRequest A bare-bones invoice for a payment within the Lightning Network. With the details of the invoice, the sender has all the data necessary to send a payment to the recipient.
     *
     * @return $this
     */
    public function setPaymentRequest($paymentRequest)
    {
        $this->container['paymentRequest'] = $paymentRequest;

        return $this;
    }

    /**
     * Gets finalCltvDelta
     *
     * @return int
     */
    public function getFinalCltvDelta()
    {
        return $this->container['finalCltvDelta'];
    }

    /**
     * Sets finalCltvDelta
     *
     * @param int $finalCltvDelta The CLTV delta from the current height that should be used to set the timelock for the final hop.
     *
     * @return $this
     */
    public function setFinalCltvDelta($finalCltvDelta)
    {
        $this->container['finalCltvDelta'] = $finalCltvDelta;

        return $this;
    }

    /**
     * Gets feeLimit
     *
     * @return \Lnd\Rest\Model\LnrpcFeeLimit
     */
    public function getFeeLimit()
    {
        return $this->container['feeLimit'];
    }

    /**
     * Sets feeLimit
     *
     * @param \Lnd\Rest\Model\LnrpcFeeLimit $feeLimit The maximum number of satoshis that will be paid as a fee of the payment. This value can be represented either as a percentage of the amount being sent, or as a fixed amount of the maximum fee the user is willing the pay to send the payment.
     *
     * @return $this
     */
    public function setFeeLimit($feeLimit)
    {
        $this->container['feeLimit'] = $feeLimit;

        return $this;
    }

    /**
     * Gets outgoingChanId
     *
     * @return string
     */
    public function getOutgoingChanId()
    {
        return $this->container['outgoingChanId'];
    }

    /**
     * Sets outgoingChanId
     *
     * @param string $outgoingChanId The channel id of the channel that must be taken to the first hop. If zero, any channel may be used.
     *
     * @return $this
     */
    public function setOutgoingChanId($outgoingChanId)
    {
        $this->container['outgoingChanId'] = $outgoingChanId;

        return $this;
    }

    /**
     * Gets lastHopPubkey
     *
     * @return string
     */
    public function getLastHopPubkey()
    {
        return $this->container['lastHopPubkey'];
    }

    /**
     * Sets lastHopPubkey
     *
     * @param string $lastHopPubkey The pubkey of the last hop of the route. If empty, any hop may be used.
     *
     * @return $this
     */
    public function setLastHopPubkey($lastHopPubkey)
    {

        if (!is_null($lastHopPubkey) && (!preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $lastHopPubkey))) {
            throw new \InvalidArgumentException("invalid value for $lastHopPubkey when calling LnrpcSendRequest., must conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.");
        }

        $this->container['lastHopPubkey'] = $lastHopPubkey;

        return $this;
    }

    /**
     * Gets cltvLimit
     *
     * @return int
     */
    public function getCltvLimit()
    {
        return $this->container['cltvLimit'];
    }

    /**
     * Sets cltvLimit
     *
     * @param int $cltvLimit An optional maximum total time lock for the route. This should not exceed lnd's `--max-cltv-expiry` setting. If zero, then the value of `--max-cltv-expiry` is enforced.
     *
     * @return $this
     */
    public function setCltvLimit($cltvLimit)
    {
        $this->container['cltvLimit'] = $cltvLimit;

        return $this;
    }

    /**
     * Gets destCustomRecords
     *
     * @return map[string,string]
     */
    public function getDestCustomRecords()
    {
        return $this->container['destCustomRecords'];
    }

    /**
     * Sets destCustomRecords
     *
     * @param map[string,string] $destCustomRecords An optional field that can be used to pass an arbitrary set of TLV records to a peer which understands the new records. This can be used to pass application specific data during the payment attempt. Record types are required to be in the custom range >= 65536. When using REST, the values must be encoded as base64.
     *
     * @return $this
     */
    public function setDestCustomRecords($destCustomRecords)
    {
        $this->container['destCustomRecords'] = $destCustomRecords;

        return $this;
    }

    /**
     * Gets allowSelfPayment
     *
     * @return bool
     */
    public function getAllowSelfPayment()
    {
        return $this->container['allowSelfPayment'];
    }

    /**
     * Sets allowSelfPayment
     *
     * @param bool $allowSelfPayment If set, circular payments to self are permitted.
     *
     * @return $this
     */
    public function setAllowSelfPayment($allowSelfPayment)
    {
        $this->container['allowSelfPayment'] = $allowSelfPayment;

        return $this;
    }

    /**
     * Gets destFeatures
     *
     * @return \Lnd\Rest\Model\LnrpcFeatureBit[]
     */
    public function getDestFeatures()
    {
        return $this->container['destFeatures'];
    }

    /**
     * Sets destFeatures
     *
     * @param \Lnd\Rest\Model\LnrpcFeatureBit[] $destFeatures Features assumed to be supported by the final node. All transitive feature dependencies must also be set properly. For a given feature bit pair, either optional or remote may be set, but not both. If this field is nil or empty, the router will try to load destination features from the graph as a fallback.
     *
     * @return $this
     */
    public function setDestFeatures($destFeatures)
    {
        $this->container['destFeatures'] = $destFeatures;

        return $this;
    }

    /**
     * Gets paymentAddr
     *
     * @return string
     */
    public function getPaymentAddr()
    {
        return $this->container['paymentAddr'];
    }

    /**
     * Sets paymentAddr
     *
     * @param string $paymentAddr The payment address of the generated invoice.
     *
     * @return $this
     */
    public function setPaymentAddr($paymentAddr)
    {

        if (!is_null($paymentAddr) && (!preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $paymentAddr))) {
            throw new \InvalidArgumentException("invalid value for $paymentAddr when calling LnrpcSendRequest., must conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.");
        }

        $this->container['paymentAddr'] = $paymentAddr;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


