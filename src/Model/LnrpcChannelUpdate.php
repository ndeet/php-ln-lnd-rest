<?php
/**
 * LnrpcChannelUpdate
 *
 * PHP version 5
 *
 * @category Class
 * @package  Lnd\Rest
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * rpc.proto
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: version not set
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.8
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Lnd\Rest\Model;

use \ArrayAccess;
use \Lnd\Rest\ObjectSerializer;

/**
 * LnrpcChannelUpdate Class Doc Comment
 *
 * @category Class
 * @package  Lnd\Rest
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class LnrpcChannelUpdate implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'lnrpcChannelUpdate';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'signature' => 'string',
        'chainHash' => 'string',
        'chanId' => 'string',
        'timestamp' => 'int',
        'messageFlags' => 'int',
        'channelFlags' => 'int',
        'timeLockDelta' => 'int',
        'htlcMinimumMsat' => 'string',
        'baseFee' => 'int',
        'feeRate' => 'int',
        'htlcMaximumMsat' => 'string',
        'extraOpaqueData' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'signature' => 'byte',
        'chainHash' => 'byte',
        'chanId' => 'uint64',
        'timestamp' => 'int64',
        'messageFlags' => 'int64',
        'channelFlags' => 'int64',
        'timeLockDelta' => 'int64',
        'htlcMinimumMsat' => 'uint64',
        'baseFee' => 'int64',
        'feeRate' => 'int64',
        'htlcMaximumMsat' => 'uint64',
        'extraOpaqueData' => 'byte'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'signature' => 'signature',
        'chainHash' => 'chain_hash',
        'chanId' => 'chan_id',
        'timestamp' => 'timestamp',
        'messageFlags' => 'message_flags',
        'channelFlags' => 'channel_flags',
        'timeLockDelta' => 'time_lock_delta',
        'htlcMinimumMsat' => 'htlc_minimum_msat',
        'baseFee' => 'base_fee',
        'feeRate' => 'fee_rate',
        'htlcMaximumMsat' => 'htlc_maximum_msat',
        'extraOpaqueData' => 'extra_opaque_data'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'signature' => 'setSignature',
        'chainHash' => 'setChainHash',
        'chanId' => 'setChanId',
        'timestamp' => 'setTimestamp',
        'messageFlags' => 'setMessageFlags',
        'channelFlags' => 'setChannelFlags',
        'timeLockDelta' => 'setTimeLockDelta',
        'htlcMinimumMsat' => 'setHtlcMinimumMsat',
        'baseFee' => 'setBaseFee',
        'feeRate' => 'setFeeRate',
        'htlcMaximumMsat' => 'setHtlcMaximumMsat',
        'extraOpaqueData' => 'setExtraOpaqueData'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'signature' => 'getSignature',
        'chainHash' => 'getChainHash',
        'chanId' => 'getChanId',
        'timestamp' => 'getTimestamp',
        'messageFlags' => 'getMessageFlags',
        'channelFlags' => 'getChannelFlags',
        'timeLockDelta' => 'getTimeLockDelta',
        'htlcMinimumMsat' => 'getHtlcMinimumMsat',
        'baseFee' => 'getBaseFee',
        'feeRate' => 'getFeeRate',
        'htlcMaximumMsat' => 'getHtlcMaximumMsat',
        'extraOpaqueData' => 'getExtraOpaqueData'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['signature'] = isset($data['signature']) ? $data['signature'] : null;
        $this->container['chainHash'] = isset($data['chainHash']) ? $data['chainHash'] : null;
        $this->container['chanId'] = isset($data['chanId']) ? $data['chanId'] : null;
        $this->container['timestamp'] = isset($data['timestamp']) ? $data['timestamp'] : null;
        $this->container['messageFlags'] = isset($data['messageFlags']) ? $data['messageFlags'] : null;
        $this->container['channelFlags'] = isset($data['channelFlags']) ? $data['channelFlags'] : null;
        $this->container['timeLockDelta'] = isset($data['timeLockDelta']) ? $data['timeLockDelta'] : null;
        $this->container['htlcMinimumMsat'] = isset($data['htlcMinimumMsat']) ? $data['htlcMinimumMsat'] : null;
        $this->container['baseFee'] = isset($data['baseFee']) ? $data['baseFee'] : null;
        $this->container['feeRate'] = isset($data['feeRate']) ? $data['feeRate'] : null;
        $this->container['htlcMaximumMsat'] = isset($data['htlcMaximumMsat']) ? $data['htlcMaximumMsat'] : null;
        $this->container['extraOpaqueData'] = isset($data['extraOpaqueData']) ? $data['extraOpaqueData'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['signature']) && !preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $this->container['signature'])) {
            $invalidProperties[] = "invalid value for 'signature', must be conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.";
        }

        if (!is_null($this->container['chainHash']) && !preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $this->container['chainHash'])) {
            $invalidProperties[] = "invalid value for 'chainHash', must be conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.";
        }

        if (!is_null($this->container['extraOpaqueData']) && !preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $this->container['extraOpaqueData'])) {
            $invalidProperties[] = "invalid value for 'extraOpaqueData', must be conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets signature
     *
     * @return string
     */
    public function getSignature()
    {
        return $this->container['signature'];
    }

    /**
     * Sets signature
     *
     * @param string $signature The signature that validates the announced data and proves the ownership of node id.
     *
     * @return $this
     */
    public function setSignature($signature)
    {

        if (!is_null($signature) && (!preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $signature))) {
            throw new \InvalidArgumentException("invalid value for $signature when calling LnrpcChannelUpdate., must conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.");
        }

        $this->container['signature'] = $signature;

        return $this;
    }

    /**
     * Gets chainHash
     *
     * @return string
     */
    public function getChainHash()
    {
        return $this->container['chainHash'];
    }

    /**
     * Sets chainHash
     *
     * @param string $chainHash The target chain that this channel was opened within. This value should be the genesis hash of the target chain. Along with the short channel ID, this uniquely identifies the channel globally in a blockchain.
     *
     * @return $this
     */
    public function setChainHash($chainHash)
    {

        if (!is_null($chainHash) && (!preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $chainHash))) {
            throw new \InvalidArgumentException("invalid value for $chainHash when calling LnrpcChannelUpdate., must conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.");
        }

        $this->container['chainHash'] = $chainHash;

        return $this;
    }

    /**
     * Gets chanId
     *
     * @return string
     */
    public function getChanId()
    {
        return $this->container['chanId'];
    }

    /**
     * Sets chanId
     *
     * @param string $chanId The unique description of the funding transaction.
     *
     * @return $this
     */
    public function setChanId($chanId)
    {
        $this->container['chanId'] = $chanId;

        return $this;
    }

    /**
     * Gets timestamp
     *
     * @return int
     */
    public function getTimestamp()
    {
        return $this->container['timestamp'];
    }

    /**
     * Sets timestamp
     *
     * @param int $timestamp A timestamp that allows ordering in the case of multiple announcements. We should ignore the message if timestamp is not greater than the last-received.
     *
     * @return $this
     */
    public function setTimestamp($timestamp)
    {
        $this->container['timestamp'] = $timestamp;

        return $this;
    }

    /**
     * Gets messageFlags
     *
     * @return int
     */
    public function getMessageFlags()
    {
        return $this->container['messageFlags'];
    }

    /**
     * Sets messageFlags
     *
     * @param int $messageFlags The bitfield that describes whether optional fields are present in this update. Currently, the least-significant bit must be set to 1 if the optional field MaxHtlc is present.
     *
     * @return $this
     */
    public function setMessageFlags($messageFlags)
    {
        $this->container['messageFlags'] = $messageFlags;

        return $this;
    }

    /**
     * Gets channelFlags
     *
     * @return int
     */
    public function getChannelFlags()
    {
        return $this->container['channelFlags'];
    }

    /**
     * Sets channelFlags
     *
     * @param int $channelFlags The bitfield that describes additional meta-data concerning how the update is to be interpreted. Currently, the least-significant bit must be set to 0 if the creating node corresponds to the first node in the previously sent channel announcement and 1 otherwise. If the second bit is set, then the channel is set to be disabled.
     *
     * @return $this
     */
    public function setChannelFlags($channelFlags)
    {
        $this->container['channelFlags'] = $channelFlags;

        return $this;
    }

    /**
     * Gets timeLockDelta
     *
     * @return int
     */
    public function getTimeLockDelta()
    {
        return $this->container['timeLockDelta'];
    }

    /**
     * Sets timeLockDelta
     *
     * @param int $timeLockDelta The minimum number of blocks this node requires to be added to the expiry of HTLCs. This is a security parameter determined by the node operator. This value represents the required gap between the time locks of the incoming and outgoing HTLC's set to this node.
     *
     * @return $this
     */
    public function setTimeLockDelta($timeLockDelta)
    {
        $this->container['timeLockDelta'] = $timeLockDelta;

        return $this;
    }

    /**
     * Gets htlcMinimumMsat
     *
     * @return string
     */
    public function getHtlcMinimumMsat()
    {
        return $this->container['htlcMinimumMsat'];
    }

    /**
     * Sets htlcMinimumMsat
     *
     * @param string $htlcMinimumMsat The minimum HTLC value which will be accepted.
     *
     * @return $this
     */
    public function setHtlcMinimumMsat($htlcMinimumMsat)
    {
        $this->container['htlcMinimumMsat'] = $htlcMinimumMsat;

        return $this;
    }

    /**
     * Gets baseFee
     *
     * @return int
     */
    public function getBaseFee()
    {
        return $this->container['baseFee'];
    }

    /**
     * Sets baseFee
     *
     * @param int $baseFee The base fee that must be used for incoming HTLC's to this particular channel. This value will be tacked onto the required for a payment independent of the size of the payment.
     *
     * @return $this
     */
    public function setBaseFee($baseFee)
    {
        $this->container['baseFee'] = $baseFee;

        return $this;
    }

    /**
     * Gets feeRate
     *
     * @return int
     */
    public function getFeeRate()
    {
        return $this->container['feeRate'];
    }

    /**
     * Sets feeRate
     *
     * @param int $feeRate The fee rate that will be charged per millionth of a satoshi.
     *
     * @return $this
     */
    public function setFeeRate($feeRate)
    {
        $this->container['feeRate'] = $feeRate;

        return $this;
    }

    /**
     * Gets htlcMaximumMsat
     *
     * @return string
     */
    public function getHtlcMaximumMsat()
    {
        return $this->container['htlcMaximumMsat'];
    }

    /**
     * Sets htlcMaximumMsat
     *
     * @param string $htlcMaximumMsat The maximum HTLC value which will be accepted.
     *
     * @return $this
     */
    public function setHtlcMaximumMsat($htlcMaximumMsat)
    {
        $this->container['htlcMaximumMsat'] = $htlcMaximumMsat;

        return $this;
    }

    /**
     * Gets extraOpaqueData
     *
     * @return string
     */
    public function getExtraOpaqueData()
    {
        return $this->container['extraOpaqueData'];
    }

    /**
     * Sets extraOpaqueData
     *
     * @param string $extraOpaqueData The set of data that was appended to this message, some of which we may not actually know how to iterate or parse. By holding onto this data, we ensure that we're able to properly validate the set of signatures that cover these new fields, and ensure we're able to make upgrades to the network in a forwards compatible manner.
     *
     * @return $this
     */
    public function setExtraOpaqueData($extraOpaqueData)
    {

        if (!is_null($extraOpaqueData) && (!preg_match("/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/", $extraOpaqueData))) {
            throw new \InvalidArgumentException("invalid value for $extraOpaqueData when calling LnrpcChannelUpdate., must conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.");
        }

        $this->container['extraOpaqueData'] = $extraOpaqueData;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


